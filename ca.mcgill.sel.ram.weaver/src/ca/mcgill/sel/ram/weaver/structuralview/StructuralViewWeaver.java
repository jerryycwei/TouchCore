package ca.mcgill.sel.ram.weaver.structuralview;

import ca.mcgill.sel.ram.Aspect;
import ca.mcgill.sel.ram.Class;
import ca.mcgill.sel.ram.Classifier;
import ca.mcgill.sel.ram.Instantiation;
import ca.mcgill.sel.ram.weaver.util.WeavingInformation;

/**
 * This is the class that represents our structural view weaver.
 * @author walabe
 *
 */
public final class StructuralViewWeaver {
    
    /**
     * The singleton instance.
     */
    private static StructuralViewWeaver instance;
    
    /**
     * Field to store if this was a depends or extends weaving.
     */
    private boolean isExtends;
    
    /**
     * Field to store all the weavingInformation generated by the weaver.
     */
    private WeavingInformation weavingInformation;
    
    /**
     * Our Constructor it initializes our attributes.
     */
    private StructuralViewWeaver() {
        isExtends = false;
    }
    
    /**
     * Returns the singleton instance of the {@link StructuralViewWeaver}.
     * 
     * @return the singleton instance
     */
    public static StructuralViewWeaver getInstance() {
        if (instance == null) {
            instance = new StructuralViewWeaver();
        }
        
        return instance;
    }
    
    /**
     * The main method of our class structural view weaver
     * that is called to perform weaving for a given instantiation.
     * @param higherLevelAspect The aspect we want to weave into
     * @param lowerLevelInstantiation The instantiation to the aspect we want to weave into higherLevelAspect
     * @return The newly woven aspect
     */
    public Aspect weave(Aspect higherLevelAspect, Instantiation lowerLevelInstantiation) {
        // Reset the class variables this is important
        // for weaveAll when we perform recursive weaving
        isExtends = false;
        
        weavingInformation = new WeavingInformation();
        
        Aspect baseCopy;
        Aspect externalAspect = lowerLevelInstantiation.getSource();
        // 1. Perform the pre-processing phase and populating weavingInformation data-structure.
        isExtends = PreProcessor.performPreProcess(lowerLevelInstantiation, higherLevelAspect, weavingInformation);
        // 2. Perform the weaving phase.
        baseCopy = weave(higherLevelAspect, externalAspect);
        // 3. Perform the post-processing phase and update all the references.
        PostProcessor.performUpdates(higherLevelAspect, externalAspect, weavingInformation, lowerLevelInstantiation);
        
        // return the new woven base with the lower level aspect woven into it.
        return baseCopy;
    }
    
    /**
     * Private helper weave method is called after all pre-processing is performed.
     * @param higherLevelAspect The aspect we want to weave lowerLevelAspect into
     * @param lowerLevelAspect The aspect that is woven into higherLevelAspect
     * @return The newly Woven aspect
     */
    private Aspect weave(final Aspect higherLevelAspect, final Aspect lowerLevelAspect) {
        
        // loop through all the classes of the dependee and figure out which
        // need to be merged
        // since they where mapped to by a class in a higher level aspect
        for (Classifier classFromLowerLevel : lowerLevelAspect.getStructuralView().getClasses()) {
            // next find the class that mapped to this clss in the lower level
            // aspect
            for (Classifier classFromHigherLevel : weavingInformation.getToElements(classFromLowerLevel)) {
                // now perform the weaving
                // TODO this will not work if implementation classes can be
                // mapped to regular classes
                // First weave in the attributes
                if (classFromLowerLevel instanceof Class && classFromHigherLevel instanceof Class) {
                    AttributesWeaver.weaveAttributes((Class) classFromHigherLevel, (Class) classFromLowerLevel,
                            weavingInformation);
                }
                // weaving of associations and operations is common to both classes and implementation classes
                AssociationsWeaver.weaveAssociations(classFromHigherLevel, classFromLowerLevel,
                        higherLevelAspect, weavingInformation);
                
                OperationsWeaver.weaveOperations(classFromHigherLevel, classFromLowerLevel,
                        higherLevelAspect, isExtends, weavingInformation);
                
                // Weave inheritance.
                for (Classifier parent : classFromLowerLevel.getSuperTypes()) {                    
                    if (!classFromHigherLevel.getSuperTypes().contains(parent)) {
                        classFromHigherLevel.getSuperTypes().add(parent);
                    }
                }
            }
        }
        
        return higherLevelAspect;
    }
    
    /**
     * Getter for weavingInformation.
     * @return our weaving information data-structure
     */
    public WeavingInformation getWeavingInformation() {
        return weavingInformation;
    }
}
